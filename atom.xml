<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tony Xiong 的博客站点</title>
  
  <subtitle>Tony Xiong的记录</subtitle>
  <link href="http://hans1980775481.github.io/atom.xml" rel="self"/>
  
  <link href="http://hans1980775481.github.io/"/>
  <updated>2021-02-02T02:22:00.522Z</updated>
  <id>http://hans1980775481.github.io/</id>
  
  <author>
    <name>Tony Xiong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何同步多个 git 远程仓库</title>
    <link href="http://hans1980775481.github.io/2021/02/02/ru-he-tong-bu-duo-ge-git-yuan-cheng-cang-ku/"/>
    <id>http://hans1980775481.github.io/2021/02/02/ru-he-tong-bu-duo-ge-git-yuan-cheng-cang-ku/</id>
    <published>2021-02-02T02:09:49.000Z</published>
    <updated>2021-02-02T02:22:00.522Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日常需求"><a href="#日常需求" class="headerlink" title="日常需求"></a>日常需求</h3><p>以前源码是托管在 github 的, 现在想要同步托管在 gitee, 一做备份分发, 二方便国内下载使用(网速可观), 三防止被墙…</p><h3 id="方式一-使用-gitee-的强制同步"><a href="#方式一-使用-gitee-的强制同步" class="headerlink" title="方式一 使用 gitee 的强制同步"></a>方式一 使用 gitee 的强制同步</h3><p>之前在 github 托管了这么一个项目 mirrors-in-china, 后来国内出了 gitee, 那么想着把项目同步一份到 gitee, 方便大家查看… 正巧 gitee 提供强制同步功能, 方便操作…</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20210202102142510.png" alt="image-20210202102142510"></p><p>我还是只用维护 github 那份源码, gitee 这边没忘记的话, 手搓点击下强制同步按钮即可.</p><p>但是容易忘记, 造成两边不完全同步.</p><p>不过我这个项目本身就非常简单, 这点同步时差完全没大问题, 够用, 并且没有其他任何多余的操作.</p><h3 id="方式二-手搓-push-多次"><a href="#方式二-手搓-push-多次" class="headerlink" title="方式二 手搓 push 多次"></a>方式二 手搓 push 多次</h3><p>换另一个项目来说, 我之前在 github 托管了这么一个项目 GlobalScanner.Sdk, 应广大小伙伴需求, 希望把项目在国内同步一份, 方便下载/参考/使用.</p><p>那么不外乎就是配置多个远程库地址, 多次推送咯, 那么我们先来看看现有远程库的情况:</p><pre class=" language-shell"><code class="language-shell">$ git remote --verboseorigin  git@github.com:taadis/GlobalScanner.Sdk.git (fetch)origin  git@github.com:taadis/GlobalScanner.Sdk.git (push)</code></pre><p>可以看到目前仅有 <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:taadis/GlobalScanner.Sdk.git 这个远程库地址.</p><p>我们来加一个 gitee 的远程地址, 首先在 gitee 建好同步仓库, 然后我们在本地添加一个新的远程库地址:</p><pre class=" language-git"><code class="language-git"><span class="token command">$ git remote add giteeorigin git@gitee.com:taadis/GlobalScanner.Sdk.git</span></code></pre><p>添加完成后我们查看一下:</p><pre class=" language-shell"><code class="language-shell">$ git remote --verbosegiteeorigin     git@gitee.com:taadis/GlobalScanner.Sdk.git (fetch)giteeorigin     git@gitee.com:taadis/GlobalScanner.Sdk.git (push)origin  git@github.com:taadis/GlobalScanner.Sdk.git (fetch)origin  git@github.com:taadis/GlobalScanner.Sdk.git (push)</code></pre><p>可以查看到以下2个远程库地址:</p><p>giteeorigin: 是我们新加的 gitee 的远程库地址</p><p>origin: 是我们之前在 github 的远程库地址</p><p>接下来同步:</p><pre class=" language-shell"><code class="language-shell">git add .git commit -m "add gitee"git push -u origin mastergit push -u giteeorigin master</code></pre><p>有链接有真相:</p><p>github:</p><p><a href="https://github.com/taadis/GlobalScanner.Sdk/commit/da00f0584c5a2699bb621e99a00fe15dece33d38">https://github.com/taadis/GlobalScanner.Sdk/commit/da00f0584c5a2699bb621e99a00fe15dece33d38</a></p><p>gitee:</p><p><a href="https://gitee.com/taadis/GlobalScanner.Sdk/commit/da00f0584c5a2699bb621e99a00fe15dece33d38">https://gitee.com/taadis/GlobalScanner.Sdk/commit/da00f0584c5a2699bb621e99a00fe15dece33d38</a></p><p>比之前多个一次 git push 操作…其他和之前没有太大区别…没有更多的心智负担.</p><p>但是经常容易忘记…</p><h3 id="方式三-最多跑一次"><a href="#方式三-最多跑一次" class="headerlink" title="方式三 最多跑一次"></a>方式三 最多跑一次</h3><p>不想着法偷懒的 coder 不是好程序员, 秉承 “最多跑一次” 的理念, 让我们试试怎么一次 push 统统搞定.</p><p>在本地 git 仓库里找到这个文件 .git/config, 内容如下:</p><pre class=" language-shell"><code class="language-shell">[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote "origin"]    url = git@github.com:taadis/GlobalScanner.Sdk.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]    remote = origin    merge = refs/heads/master[remote "giteeorigin"]    url = git@gitee.com:taadis/GlobalScanner.Sdk.git    fetch = +refs/heads/*:refs/remotes/giteeorigin/*</code></pre><p>改为如下:</p><p>合并2个 remote 配置</p><pre class=" language-shell"><code class="language-shell">[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote "origin"]    url = git@github.com:taadis/GlobalScanner.Sdk.git    url = git@gitee.com:taadis/GlobalScanner.Sdk.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]    remote = origin    merge = refs/heads/master</code></pre><p>上面这个手动配置是为了更好的说明而已, 其实可以用以下命令简化操作, 在 origin 节点下补充了一个新的远程地址.</p><pre class=" language-shell"><code class="language-shell">$ git remote set-url --add origin git@gitee.com:taadis/GlobalScanner.Sdk.git</code></pre><p>看看补充后的远程地址情况</p><pre class=" language-shell"><code class="language-shell">git remote --verboseorigin  git@github.com:taadis/GlobalScanner.Sdk.git (fetch)origin  git@github.com:taadis/GlobalScanner.Sdk.git (push)origin  git@gitee.com:taadis/GlobalScanner.Sdk.git (push)</code></pre><p>注意看后面的 (fetch)(push), 相信你会明白点什么.</p><p>然后我们可以继续这样使用来实现 github &amp; gitee 的同步推送和分发:</p><pre class=" language-shell"><code class="language-shell">git add .git commit -m "github & gitee 同步推送和分发"git push origin master</code></pre><p>有链接有真相:</p><p>github:</p><p><a href="https://github.com/taadis/GlobalScanner.Sdk/commit/6846226ff2be56ed0f58c9345bac4a0170f1880f">https://github.com/taadis/GlobalScanner.Sdk/commit/6846226ff2be56ed0f58c9345bac4a0170f1880f</a></p><p>gitee:</p><p><a href="https://gitee.com/taadis/GlobalScanner.Sdk/commit/6846226ff2be56ed0f58c9345bac4a0170f1880f">https://gitee.com/taadis/GlobalScanner.Sdk/commit/6846226ff2be56ed0f58c9345bac4a0170f1880f</a></p><p>可以看到, 使用上和最初没有任何区别, 只是多配置了一次, 算是实现了 “最多配(跑)一次”.</p><h3 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h3><p>几种方式, 各取所需咯.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;日常需求&quot;&gt;&lt;a href=&quot;#日常需求&quot; class=&quot;headerlink&quot; title=&quot;日常需求&quot;&gt;&lt;/a&gt;日常需求&lt;/h3&gt;&lt;p&gt;以前源码是托管在 github 的, 现在想要同步托管在 gitee, 一做备份分发, 二方便国内下载使用(网速可观), 三</summary>
      
    
    
    
    <category term="转发" scheme="http://hans1980775481.github.io/categories/%E8%BD%AC%E5%8F%91/"/>
    
    <category term="git操作" scheme="http://hans1980775481.github.io/categories/%E8%BD%AC%E5%8F%91/git%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="git" scheme="http://hans1980775481.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal 简易使用教程</title>
    <link href="http://hans1980775481.github.io/2020/12/09/windows-terminal-jian-yi-shi-yong-jiao-cheng/"/>
    <id>http://hans1980775481.github.io/2020/12/09/windows-terminal-jian-yi-shi-yong-jiao-cheng/</id>
    <published>2020-12-09T02:25:57.000Z</published>
    <updated>2020-12-10T08:44:31.038Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>相关链接：</em></strong></p><ul><li><a href="https://blog.csdn.net/weixin_42815609/article/details/107451481">Windows Terminal 窗口/控制台切换快捷键总结</a></li><li><a href="https://www.xiaoz.me/archives/15448">Windows Terminal + Alpine Linux + ZSH打造自己的高颜值终端</a></li><li><a href="http://www.python3.vip/blog/winterm/">Windows Terminal 使用技巧</a></li></ul><blockquote><p>历史配置数量太多</p></blockquote><p><img src="_image/Windows-Terminal-%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/image-20201209183543737.png" alt="image-20201209183543737"></p><pre><code>can&#39;t found node, please check your input sources or destinationsinput content does not match any node in topology, please check input or topologycan not found from intfObject in the device %s, please check sourcescan not found path, please check your address, sources:%s, destinations:%s</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关链接：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42815609/article/details/107451481&quot;&gt;Windows Terminal 窗</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Java中的WeakReference</title>
    <link href="http://hans1980775481.github.io/2020/12/07/guan-yu-java-zhong-de-weakreference/"/>
    <id>http://hans1980775481.github.io/2020/12/07/guan-yu-java-zhong-de-weakreference/</id>
    <published>2020-12-07T10:25:01.000Z</published>
    <updated>2020-12-07T11:29:21.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><blockquote><p>在看ThreadLocal源码的时候，其中嵌套类ThreadLocalMap中的Entry继承了WeakReferenc，为了能搞清楚ThreadLocal，只能先了解下了WeakReferenc(是的，很多时候为了搞清楚一个东西，不得不往上追好几层，先搞清楚其所依赖的东西。)<br> 下面进入正题，WeakReference如字面意思，弱引用， 当一个对象仅仅被weak reference（弱引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。</p></blockquote><h3 id="二-认识WeakReference类"><a href="#二-认识WeakReference类" class="headerlink" title="二. 认识WeakReference类"></a>二. 认识WeakReference类</h3><p>WeakReference继承Reference，其中只有两个构造函数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span>T referent<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeakReference</span><span class="token punctuation">(</span>T referent<span class="token punctuation">,</span> ReferenceQueue<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> q<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>WeakReference(T referent)：referent就是被弱引用的对象（注意区分弱引用对象和被弱引用的对应，弱引用对象是指WeakReference的实例或者其子类的实例），比如有一个Apple实例apple，可以如下使用，并且通过get()方法来获取apple引用。也可以再创建一个继承WeakReference的类来对Apple进行弱引用，下面就会使用这种方式。</li></ul><pre class=" language-java"><code class="language-java">WeakReference<span class="token operator">&lt;</span>Apple<span class="token operator">></span> appleWeakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>Apple apple2 <span class="token operator">=</span> appleWeakReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q)：与上面的构造方法比较，多了个ReferenceQueue，在对象被回收后，会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了。</li></ul><h3 id="三-使用WeakReference"><a href="#三-使用WeakReference" class="headerlink" title="三. 使用WeakReference"></a>三. 使用WeakReference</h3><p>下面是使用继承WeakReference的方式来使用软引用，并且不使用ReferenceQueue。</p><h4 id="简单类Apple"><a href="#简单类Apple" class="headerlink" title="简单类Apple"></a>简单类Apple</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>brightloong<span class="token punctuation">.</span>lab<span class="token punctuation">.</span>reference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Apple class * * @author BrightLoong * @date 2018/5/25 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Apple</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 覆盖finalize，在回收的时候会执行。     * @throws Throwable     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple： "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">" finalize。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"Apple&amp;#123;"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'&amp;#125;'</span> <span class="token operator">+</span> <span class="token string">", hashCode:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="继承WeakReference的Salad"><a href="#继承WeakReference的Salad" class="headerlink" title="继承WeakReference的Salad"></a>继承WeakReference的Salad</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>brightloong<span class="token punctuation">.</span>lab<span class="token punctuation">.</span>reference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Salad class * 继承WeakReference，将Apple作为弱引用。 * 注意到时候回收的是Apple，而不是Salad * * @author BrightLoong * @date 2018/5/25 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Salad</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Salad</span><span class="token punctuation">(</span>Apple apple<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="Clent调用和输出"><a href="#Clent调用和输出" class="headerlink" title="Clent调用和输出"></a>Clent调用和输出</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>brightloong<span class="token punctuation">.</span>lab<span class="token punctuation">.</span>reference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Main class * * @author BrightLoong * @date 2018/5/24 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Salad salad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Salad</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token string">"红富士"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过WeakReference的get()方法获取Apple</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Apple:"</span> <span class="token operator">+</span> salad<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//休眠一下，在运行的时候加上虚拟机参数-XX:+PrintGCDetails，输出gc信息，确定gc发生了。</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果为空，代表被回收了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>salad<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"clear Apple。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>输出如下：</p><pre class=" language-rust"><code class="language-rust">Apple<span class="token punctuation">:</span>Apple<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">'红富士'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> hashCode<span class="token punctuation">:</span><span class="token number">1846274136</span><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>PSYoungGen<span class="token punctuation">:</span> 3328K<span class="token punctuation">-></span><span class="token function">496K</span><span class="token punctuation">(</span>38400K<span class="token punctuation">)</span><span class="token punctuation">]</span> 3328K<span class="token punctuation">-></span><span class="token function">504K</span><span class="token punctuation">(</span>125952K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0035102</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token punctuation">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.01</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Full <span class="token function">GC</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>PSYoungGen<span class="token punctuation">:</span> 496K<span class="token punctuation">-></span><span class="token function">0K</span><span class="token punctuation">(</span>38400K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>ParOldGen<span class="token punctuation">:</span> 8K<span class="token punctuation">-></span><span class="token function">359K</span><span class="token punctuation">(</span>87552K<span class="token punctuation">)</span><span class="token punctuation">]</span> 504K<span class="token punctuation">-></span><span class="token function">359K</span><span class="token punctuation">(</span>125952K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Metaspace<span class="token punctuation">:</span> 2877K<span class="token punctuation">-></span><span class="token function">2877K</span><span class="token punctuation">(</span>1056768K<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0.0067965</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token punctuation">:</span> user<span class="token operator">=</span><span class="token number">0.00</span> sys<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span> Apple： 红富士 finalize。clear Apple。</code></pre><h4 id="ReferenceQueue的使用"><a href="#ReferenceQueue的使用" class="headerlink" title="ReferenceQueue的使用"></a>ReferenceQueue的使用</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> io<span class="token punctuation">.</span>github<span class="token punctuation">.</span>brightloong<span class="token punctuation">.</span>lab<span class="token punctuation">.</span>reference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>Reference<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>ReferenceQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ref<span class="token punctuation">.</span>WeakReference<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Client2 class * * @author BrightLoong * @date 2018/5/27 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client2</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ReferenceQueue<span class="token operator">&lt;</span>Apple<span class="token operator">></span> appleReferenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WeakReference<span class="token operator">&lt;</span>Apple<span class="token operator">></span> appleWeakReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token string">"青苹果"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> appleReferenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        WeakReference<span class="token operator">&lt;</span>Apple<span class="token operator">></span> appleWeakReference2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token string">"毒苹果"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> appleReferenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====gc调用前====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Reference<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token operator">></span> reference <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>reference <span class="token operator">=</span> appleReferenceQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//不会输出，因为没有回收被弱引用的对象，并不会加入队列中</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====调用gc====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====gc调用后====="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//下面两个输出为null,表示对象被回收了</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>appleWeakReference2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出结果，并且就是上面的appleWeakReference、appleWeakReference2，再次证明对象被回收了</span>        Reference<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span><span class="token operator">></span> reference2 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>reference2 <span class="token operator">=</span> appleReferenceQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果使用继承的方式就可以包含其他信息了</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"appleReferenceQueue中："</span> <span class="token operator">+</span> reference2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>结果输出如下：</p><pre class=" language-csharp"><code class="language-csharp"><span class="token operator">===</span><span class="token operator">==</span>gc调用前<span class="token operator">===</span><span class="token operator">==</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token keyword">ref</span><span class="token punctuation">.</span>WeakReference@6e0be858java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token keyword">ref</span><span class="token punctuation">.</span>WeakReference@61bbe9baApple<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">'青苹果'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> hashCode<span class="token punctuation">:</span><span class="token number">1627674070</span>Apple<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token operator">=</span><span class="token string">'毒苹果'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> hashCode<span class="token punctuation">:</span><span class="token number">1360875712</span><span class="token operator">===</span><span class="token operator">==</span>调用gc<span class="token operator">===</span><span class="token operator">==</span>Apple： 毒苹果 finalize。Apple： 青苹果 finalize。<span class="token operator">===</span><span class="token operator">==</span>gc调用后<span class="token operator">===</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token keyword">null</span>appleReferenceQueue中：java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token keyword">ref</span><span class="token punctuation">.</span>WeakReference@6e0be858appleReferenceQueue中：java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span><span class="token keyword">ref</span><span class="token punctuation">.</span>WeakReference@61bbe9baProcess finished with exit code <span class="token number">0</span></code></pre><p>可以看到在队列中（ReferenceQueue），调用gc之前是没有内容的，调用gc之后，对象被回收了，并且弱引用对象appleWeakReference和appleWeakReference2被放入了队列中。</p><p>关于其他三种引用，强引用、软引用、虚引用，可以参考<a href="http://www.cnblogs.com/gudi/p/6403953.html">http://www.cnblogs.com/gudi/p/6403953.html</a></p><p><strong><em>原文链接：</em></strong></p><ul><li><a href="https://www.jianshu.com/p/964fbc30151a">关于Java中的WeakReference</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一. 简介&quot;&gt;&lt;/a&gt;一. 简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在看ThreadLocal源码的时候，其中嵌套类ThreadLocalMap中的Entry继承</summary>
      
    
    
    
    <category term="Java知识路线" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="转发" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/%E8%BD%AC%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://hans1980775481.github.io/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="http://hans1980775481.github.io/tags/ThreadLocal/"/>
    
    <category term="弱引用" scheme="http://hans1980775481.github.io/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>靠这 18 张图，我学会了一致性哈希</title>
    <link href="http://hans1980775481.github.io/2020/11/21/kao-zhe-18-zhang-tu-wo-xue-hui-liao-yi-zhi-xing-ha-xi/"/>
    <id>http://hans1980775481.github.io/2020/11/21/kao-zhe-18-zhang-tu-wo-xue-hui-liao-yi-zhi-xing-ha-xi/</id>
    <published>2020-11-21T03:27:05.000Z</published>
    <updated>2020-11-21T03:45:40.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当架构师大刘看到实习生小李提交的<strong>记账流水乱序</strong>的问题的时候，他知道没错了：这一次，大刘又要用一致性哈希这个老伙计来解决这个问题了。</p><p>嗯，一致性哈希，分布式架构师必备良药，让我们一起来尝尝它。</p><h2 id="1-满眼都是自己二十年前的样子，让我们从哈希开始"><a href="#1-满眼都是自己二十年前的样子，让我们从哈希开始" class="headerlink" title="1. 满眼都是自己二十年前的样子，让我们从哈希开始"></a>1. 满眼都是自己二十年前的样子，让我们从哈希开始</h2><p>在 N 年前，互联网的分布式架构方兴未艾。大刘所在的公司由于业务需要，引入了一套由 IBM 团队设计的业务架构。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113535224.png" alt="image-20201121113535224"></p><p>这套架构采用了分布式的思想，通过 RabbitMQ 的消息中间件来通信。这套架构，在当时的年代里，算是思想超前，技术少见的黑科技架构了。</p><p>但是，由于当年分布式技术落地并不广泛，有很多尚不成熟的地方。所以，这套架构在经年日久的使用中，一些问题逐渐突出。其中，最典型的问题有两个：</p><ol><li>RabbitMQ 是个单点，它一坏掉，整个系统就会全部瘫痪。</li><li>收、发消息的业务系统也是单点。任何一点出现问题，对应队列的消息要么无从消费，要么海量消息堆积。</li></ol><p>无论哪种问题，最终是整套分布式系统都无法使用，后续处理非常麻烦。</p><p>对于 RabbitMQ 的单点问题，由于当时 RabbitMQ 的集群功能非常弱，普通模式有 queue 本身的单点问题，所以，最终使用了 Keepalived 配合了两台无关系的 RabbitMQ 搞出了高可用。</p><p>而对于业务系统单点问题，从一开始着手解决的时候就出现了波折。一般来说，我们要解决单点问题，方法就是堆机器，堆应用。收发是单点，我们直接多部署几个应用就可以了。如果仅仅从技术上看，无非就是多个收发消息的应用大家一起竞争往 MQ 中放消息拿消息而已。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113549628.png" alt="image-20201121113549628"></p><p>但是，恰恰就是在把收发消息的应用集群化后，系统出现了问题。</p><p>本身这套系统架构会被应用到公司的多类业务上，有些业务对消息的顺序有着苛刻的要求。</p><p>比如，公司内部的 IM 应用，不管是点对点的聊天还是群聊消息，都需要对话消息严格有序。而当我们把生产消息和消费消息的应用集群化后，问题出现了：</p><p><strong>聊天记录出现了乱序</strong></p><p>A 和 B 对话，会出现某些消息没有严格按照 A 发出的先后顺序被 B 接收，于是整个聊天顺序乱成了一锅粥。</p><p>经过排查，发现问题的根源就在于应用集群上。由于没有对应用集群收发消息做特殊的处理，当 A 发出一条聊天信息给B时，发送到 RabbitMQ 中的信息会被在 B 处的消费端所争抢。如果 A 在短时间内发出了几条信息，那么就可能会被集群中的不同应用抢走。</p><p>这时候，乱序的问题就出现了。虽然应用业务逻辑是相同的，但是这些集群中的应用依然可能在处理信息速度上出现差异，最终导致用户看到的聊天信息错乱。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113604446.png" alt="image-20201121113604446"></p><p>问题找到了，解决办法是什么？</p><p>上面我们说过了，消息顺序错乱是因为集群中不同应用抢消息然后处理速度不一样导致的。如果我们能保证 A 和 B 会话，从开始之后到会话结束之前，永远只会被 B 所在的消费消息集群应用中的同一个应用消费，那么我们就能保证消息有序。这样一来，我们就可以在消费消息的那个应用中，对抢到的消息进行排队，然后依次处理。</p><p>那么，这种保证怎么实现呢？</p><p>首先，我们在 RabbitMQ 中会建立有相同前缀的队列，后面跟着队列编号。然后，集群中的不同应用会分别监听这两个有着不同编号的队列。当在 A 发送信息时，我们会对信息做一次简单的哈希:</p><p><code>m = hash(id) mod n</code></p><p>这里，id 是用户的标识。n 是集群中 B 所在业务系统部署的数量。最终的 m 是我们需要发送到的目的队列编号。<img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113625772.png" alt="image-20201121113625772"></p><p>假设，hash(id) 的结果为 2000，n 为 2，经过计算 m = 0。此时，A 就会把他和 B 的对话信息都发送到 chat00 的队列里。B 收到消息后，就会依次显示给终端用户。这样，聊天乱序的问题就解决了。</p><p>那么，事情到此就结束了吗？这个解决方案是完美的吗？</p><h2 id="2-看来，我们需要增加应用数量了"><a href="#2-看来，我们需要增加应用数量了" class="headerlink" title="2. 看来，我们需要增加应用数量了"></a>2. 看来，我们需要增加应用数量了</h2><p>随着公司的发展，公司的人数也急剧上升，公司内部的 IM 使用人数也跟着多了起来，新问题又随之出现了。</p><p>最主要的问题是，人们收到聊天信息的速度变慢了。原因也很简单，收取聊天信息的集群机器不够用了。解决办法可以简单直接点，再加台机器就好了。</p><p>不过，由于<code>收消息的集群[消费者集群]</code>中新加入了一台机器，这时候，我们还需要额外多做一些事情：</p><ol><li>我们需要为新加入的这台机器上的应用额外再多增加一个队列 chat02。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113700896.png" alt="image-20201121113700896"></li><li>我们还需要修改下我们的分配消息的规则，把原来的 hash(id) mod 2 修改为 hash(id) mod 3。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113714678.png" alt="image-20201121113714678"></li><li>重新启动发送消息的项目，以便修改的规则生效。</li><li>把收消息的应用部署到新机器上。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113740372.png" alt="image-20201121113740372"></li></ol><p>到这时，一切还都在可控范围。开发人员只需要在需要的时候，新增加个队列，然后把我们的分配规则小小的修改下即可。</p><p>但是，他们不知道的是，暴风雨就要来了。</p><h2 id="3-新的问题来了，也许这就是人生吧"><a href="#3-新的问题来了，也许这就是人生吧" class="headerlink" title="3. 新的问题来了，也许这就是人生吧"></a>3. 新的问题来了，也许这就是人生吧</h2><p>由于公司内部很多人在使用这个 IM 工具。有些时候，为了方便，公司的客户还有一些合作方也用起了这个 IM。这让事情变得复杂了起来。起初，开发人员还是像往常一样，每当人们抱怨说收消息过慢的时候，他们就会加一台机器。</p><p>最糟糕的是，公司的客户也会抱怨，他们发现 IM 有时候彻底不可用。这可不是小事情。公司内部人员的问题还可以内部沟通解决。但是公司客户的问题，大意不得，因为这关系到公司产品的名誉。</p><p>那么，这到底是怎么一回事呢？</p><p>原来，根本原因还在于每次修改完配置规则后的重启服务。每次修改完配置规则，就需要规划好一个恰当的停机时间，去重新对项目做个上线。</p><p>但是，这种方法在公司的客户也使用这个 IM 后就行不通了。因为公司的客户有不少是在国外的。也就是说，不管白天还是深夜，很可能总是有人在使用这个 IM。</p><p>这就迫使开发人员们，在增加机器时，还需要去和多方协调沟通出一个上线时间，然后发布公告，再去上线。这种反复沟通，再上线，再反复沟通，再上线直接把开发人员们折腾了个半死。</p><p>往往沟通完，上线时间直接被放到了半个月以后。而在这半个月里，开发人员还要承受无数内部 IM 使用人的口水。费心竭力的沟通，声嘶力竭的解释，缺眠少觉的上线，这一切的一切推动着开发人员们必须对眼前这套技术方案作出改变了。</p><h2 id="4-思路转起来，队列环起来"><a href="#4-思路转起来，队列环起来" class="headerlink" title="4. 思路转起来，队列环起来"></a>4. 思路转起来，队列环起来</h2><p>新的技术方案的需求本质就是：</p><p>无论是分配消息规则变化还是集群机器添加都不能停机停服务</p><p>对于这种情况，一个很好的解决方案就是如果我们对项目配置文件进行动态的定时检测，当发现变动时，刷新配置规则即可。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113812385.png" alt="image-20201121113812385"></p><p>一切看上去很美好，采用了动态的定时检测后，每当我们需要新增集群中的机器时，我们只需要如下三个步骤了:</p><ol><li>增加一个队列</li><li>修改分配消息的规则</li><li>部署新的机器</li></ol><p>客户毫无感知，开发人员们也不需要和用户们协调沟通出专门的上线安排。可是，这个方案也存在一些问题：</p><ol><li>随着我们的系统部署越来越多，我们需要手工修改规则的系统也越来越多。</li><li>如果消费机器宕机了，我们需要删除队列，同时还需要去删除修改分配消息的规则，等到机器恢复了，我们还要再把分配消息的规则改回去。</li></ol><p>这个分配消息的规则真讨厌啊，每次有变动，就要去关心这个分配消息的规则。有没有什么办法能把这个分配变得更自动化一些呢？</p><p>如果我们假设在 MQ 中有 100 个收发聊天信息的队列（100：这是对我们的IM不可能达到的一个数字），我们只需要在配置规则中配置成：</p><p>m = hash(id) mod 100</p><p>然后，我们的发送消息的应用启动后，去动态的探测出真实的所有收发聊天信息的队列信息。</p><p>当我们通过哈希算出的编号发现没有真实对应的队列存在时，就根据一定的规则，去找到一个真实存在的队列，这个队列，就是我们要发消息的队列。</p><p>如果我们做到这样，那么以后，每次队列有变化，无论增多还是减少，我们都不需要再去考虑分配规则的事情了，只需要移除有问题的队列或者增加有对应消费者的队列即可。</p><p>这个思想，就是一致性哈希的思想。</p><p>具体怎么做呢？</p><p>第一步，我们假设有个 100 个收发聊天信息的队列，并且这些队列处于一个环上。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113842608.png" alt="image-20201121113842608"></p><p>第二步，我们获取到真实的收发聊天信息的队列数量，假设有 5 个。<img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113854095.png" alt="image-20201121113854095"></p><p>第三步，我们把真实的队列映射到我们第一步假设的环中。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113905229.png" alt="image-20201121113905229"></p><p>第四步，我们通过分配规则 hash(id) mod 100 计算出对应的队列编号。</p><p>如果 hash(id) 的结果为 2000，那么算出的队列编号 m = 0。这时候，我们一查，发现对应编号 0 的 chat00 队列确实存在，那么就直接发送消息到 chat00 中。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121113927454.png" alt="image-20201121113927454"></p><p>如果我们的 hash(id) 的结果为 1999，那么算出的队列编号 m = 99。此时，我们去查队列映射关系，发现 99 编号并没有对应的真实队列。这时候怎么办？很简单，我们顺时针继续往下找，找到谁了呢？0 对应的 chat00 队列，这是真实存在的，这时候，我们就将消息发送到 chat00 队列中。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114003835.png" alt="image-20201121114003835"></p><p>上面四步就是一个基本的一致性哈希算法了。</p><p>那么，这套一致性哈希算法满足我们不想总是更新消息分配规则的需求吗？让我们验证一下：</p><ol><li><p><strong>假设我们需要在消费信息端集群增加一台机器</strong><br>我们如果要增加一台机器，那么同时我们也需要在 MQ 中增加一个队列。这时候，我们的分配规则是 hash(id) mod 100，增加了队列后，真实的队列数假设为 6。此时，如果 hash(id) mod 100 的结果小于 6，那么分配的规则和没有增加机器的时候规则一样，以前分配到哪个队列，现在还是分配到哪个队列。但是对于结果等于 6 的情况，则发生了变化。信息会被自动分配给 chat05。当分配给 chat05 后，新的消费者就会自动开始进入正常工作了，我们不需要做任何人工干预，也不需要考虑分配规则的变化。</p><p>增加机器以前：</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114017365.png" alt="image-20201121114017365"></p><p>增加机器之后：</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114030734.png" alt="image-20201121114030734"></p></li><li><p><strong>假设消费信息端集群一台机器宕机了</strong><br>模拟宕机，此时我们会去减少一个队列。减少后的真实队列数量为 5，则正好和增加队列相反，m = 5 时，那么行为不会有任何变化，以前分到哪个队列，还是分到哪个队列。如果 m = 6，由于已经不存在真实的队列了，就会做顺时针查找，结果找到 chat00，以前会分到 chat05 的就会被分到 chat00。而此时，chat00 由于正好有消费者，所以，系统的用户是毫无感知的，我们也专心修复我们机器即可。当机器恢复后，就会和新增机器一样，计算结果为 6 的信息会被重新分配回 chat05。</p></li></ol><p>目前，我们可以看到，当我们引入一致性哈希后，我们不管新增机器还是集群机器宕机，我只需要跟随着机器的状态，做一个操作即可：增加或者减少 MQ 中的队列。一切简单化了。</p><p>那么，这个方案是否依然还有问题呢？</p><h2 id="5-失衡的圆环，压垮骆驼的可能只是一根稻草"><a href="#5-失衡的圆环，压垮骆驼的可能只是一根稻草" class="headerlink" title="5. 失衡的圆环，压垮骆驼的可能只是一根稻草"></a>5. 失衡的圆环，压垮骆驼的可能只是一根稻草</h2><p>假设我们目前有 5 个队列存在，我们的分配规则是 m = hash(id) mod 100。那么，此时，问题就出来了。</p><p>如果 m 的值大于 5，由于没有对应的真实队列存在，系统就会顺时针顺着我们构造出来的哈希环找，最终会找到 chat00 这个队列上。</p><p>然后，你会发现，只要是 m 值大于 5 的 id 对应用户发的信息，最终都会落入到 chat00 队列中。</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114124282.png" alt="image-20201121114124282"></p><p>在极端情况下，如果大量的信息涌入到 chat00 队列里，由于对应 chat00 的消费者处理不过来，很可能会导致这个消费者的崩溃。</p><p>然后，去除队列后，根据规则，又会有大量的信息涌入到 chat00 后续的队列 chat01 里，这些信息又会导致 chat01 对应应用的崩溃，最终引发整个集群的崩溃，这就是雪崩效应。</p><p>我们需要一种更巧妙的办法来解决这个问题。</p><h2 id="6-从实变虚，也许我们应该更敢想一些"><a href="#6-从实变虚，也许我们应该更敢想一些" class="headerlink" title="6. 从实变虚，也许我们应该更敢想一些"></a>6. 从实变虚，也许我们应该更敢想一些</h2><p>经过上面的论述，我们发现，我们在分配队列时，之所以失衡，是因为我们的队列在圆环上的分配失衡。</p><p>我们所有的真实队列都是按照顺时针依次排布在圆环上的。在上面的场景里，我们只有 5 个队列。此时，我们假设会有 100 个队列。那么，m = hash(id) mod 100 这个公式里：</p><p><strong>m 大于 5 的概率为 95%</strong></p><p>由于我们的 5 个队列是按照编号顺序依次排列的。那就说明所有 m 大于 5 的信息就都会映射到一个不存在的队列上，最终，根据规则，顺时针滑到了 0 对应的 chat00 队列中。</p><p>如果，我们可以让真实存在的队列均匀分布到环上，那么，这种严重失衡的现象还会再出现吗？</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114143943.png" alt="image-20201121114143943"></p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114203684.png" alt="image-20201121114203684"></p><p>从上面的图我们可以看出，如果我们能让真实的队列均匀的在圆环上分布，那么这种严重失衡的现象就会得到极大的缓解。</p><p>那么如何让这些队列能均匀的分布在这个圆环中呢？还记得我们在苦恼分配信息规则的不断修改时，我们大胆的假设了一个我们的 IM 系统永远也不可能达到的队列数字吗？</p><p>我们假设了 MQ 中有 100 个队列，然后，我们去判断这些队列是否真实存在。不存在，我们就顺时针滑动一直找到真实存在的队列为止。</p><p>如果我们再大胆一点，偷偷的把我们的假设进一步优化，把一些本来需要判断为不存在的队列去映射到真正已经存在的队列上，那么我们是不是就等于把这些真正存在的队列均匀分布到这个圆环上了？</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201121114229378.png" alt="image-20201121114229378"></p><p>像上图这种，把已经存在的少量队列去映射到多个假设队列的方法，就是一致性哈希的虚拟节点办法。</p><p>而对于怎么让少量的队列映射到多个假设队列，是有多种实现算法存在的。</p><p>比如，我们可以把真实存在的队列名加上一些编号去分别哈希一下, 像hash(chat00) mod 100，hash(chat00#1) mod 100，然后根据得到的余数，去把 chat00 这个真实队列和对应余数的环中的位置映射上。</p><p>如果 hash(chat00) mod 100 = 31，那么 31 号的位置就对应于 chat00，以后所有 m = hash(id) mod 100 中 m = 31的所对应的消息就会直接被发送到 chat00 队列。</p><p>而 hash(00#1) mod 100 = 56，则 m = 56对应的消息同样也会直接发送到 chat00 队列。</p><p>这样，我们就间接的把 MQ 中的真实存在的队列做了均匀化分布，从而大大减少了信息失衡的现象。</p><h2 id="7-理解算法的思想胜于算法的实现"><a href="#7-理解算法的思想胜于算法的实现" class="headerlink" title="7. 理解算法的思想胜于算法的实现"></a>7. 理解算法的思想胜于算法的实现</h2><p>好了，通过实际场景来对于一致性哈希的思想就暂时剖析到这里了。</p><p>一致性哈希作为一种非常经典的算法思想，被广泛的用于各大分布式项目当中，用于解决各种分片问题，任务分发问题。</p><p>但是，在这里，我要纠正一个观点：很多人都在网上说 redis 使用了一致性哈希。这是错的，redis 只是使用了一致性哈希的思想。比如一致性哈希中的环分布，再比如虚拟节点对应真实节点的思想。</p><p>但是 redis 并没有使用任何哈希算法去计算分布，如果有兴趣的读者，可以仔细去看下有关内容。从 redis 的例子上来说，我们可以看到，只有理解了算法的思想，我们才能更容易更灵活地因地制宜的分解、修正、改进算法，让算法能更切合实际的融入到我们的项目之中。</p><p>通过这篇文章我们从哈希开始，一直到用到一致性哈希的虚拟节点分布，怎么样，您觉得一致性哈希这道良药味道如何呢？</p><p><strong><em>原文链接</em></strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247494768&idx=2&sn=db137be19e8b96925149417a3e88ea5b&chksm=ebd4ad71dca324676ff765a3ee19fea84fab168c556897178f578bbb33899d3ade49db22f258&mpshare=1&scene=24&srcid=1119AzbaXz20tzHLD3WvkxR4&sharer_sharetime=1605759171653&sharer_shareid=0c62ce0359ab0b4c93ed31d8ff14913a&key=7cef430a7b17c87e5de58639377655c287a2c83355fd1f2b468fa418ffb15fe9266cd29f3bc0901aa42da56023f6bf7f3b7d27030024e1344b98f3dd9b45253a9f311cfc35350281a62d65c2c545eefc11f15a4b1d518fcf87a5a9f8272105521ad8d89791037fbd4b31e93df2bdb11e1b4059053ea5b3e3b6be746b4fd709e2&ascene=14&uin=MjI5MDgzMTc4NA==&devicetype=Windows+10+x64&version=6209051a&lang=zh_CN&exportkey=AcC+eEGu1f+1vmog9quiNMY=&pass_ticket=6XgRGLrAqhle+bSrdN+6QFvwY1uaRPvLhUFBZ2tKEvS8v1vNKrHGEoXZwPWRYTZ5&wx_header=0">靠这 18 张图，我学会了一致性哈希</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当架构师大刘看到实习生小李提交的&lt;strong&gt;记账流水乱序&lt;/strong&gt;的问题的时候，他知道没错了：这一次，大刘又要用一致性哈希这个老</summary>
      
    
    
    
    <category term="Java知识路线" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="转发" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/%E8%BD%AC%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://hans1980775481.github.io/tags/Java/"/>
    
    <category term="一致性hash" scheme="http://hans1980775481.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
    
    <category term="RabbitMQ" scheme="http://hans1980775481.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>图文并茂：HashMap经典详解！</title>
    <link href="http://hans1980775481.github.io/2020/11/03/tu-wen-bing-mao-hashmap-jing-dian-xiang-jie/"/>
    <id>http://hans1980775481.github.io/2020/11/03/tu-wen-bing-mao-hashmap-jing-dian-xiang-jie/</id>
    <published>2020-11-03T15:02:59.000Z</published>
    <updated>2020-11-03T15:13:25.888Z</updated>
    
    <content type="html"><![CDATA[<p>代码中的注解多看几遍，其中HashMap的扩容机制是要必懂知识！结合图片一起理解！</p><h3 id="什么是-HashMap"><a href="#什么是-HashMap" class="headerlink" title="什么是 HashMap?"></a>什么是 HashMap?</h3><p>HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>HashMap 的数据结构 在 Java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap 也不例外。HashMap 实际上是一个 “链表散列” 的数据结构，即数组和链表的结合体。</p><p>文字描述永远要配上图才能更好的讲解数据结构，HashMap 的结构图如下。 </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/640" alt="img"></p><p>从上图中可以看出，HashMap 底层就是一个数组结构，数组中的每一项又是一个链表或者红黑树。当新建一个 HashMap 的时候，就会初始化一个数组。</p><p>下面先通过大概看下 HashMap 的核心成员。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 默认容量，默认为16，必须是2的幂</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最大容量，值是2^30</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span>    <span class="token comment" spellcheck="true">// 装载因子，默认的装载因子是0.75</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 解决冲突的数据结构由链表转换成树的阈值，默认为8</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 解决冲突的数据结构由树转换成链表的阈值，默认为6</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 当桶中的bin被树化时最小的hash表容量。     * 如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作。     * 这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储数据的数组</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历的容器</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Map中KEY-VALUE的数量</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 结构性变更的次数。     * 结构性变更是指map的元素数量的变化，比如rehash操作。     * 用于HashMap快速失败操作，比如在遍历时发生了结构性变更，就会抛出ConcurrentModificationException。     */</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下次resize的操作的size值。</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 负载因子，resize后容量的大小会增加现有size * loadFactor</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="HashMap-的初始化"><a href="#HashMap-的初始化" class="headerlink" title="HashMap 的初始化"></a>HashMap 的初始化</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 其他值都是默认值</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>通过源码可以看出初始化时并没有初始化数组 table，那只能在 put 操作时放入了，为什么要这样做？估计是避免初始化了 HashMap 之后不使用反而占用内存吧，哈哈哈。</p><h3 id="HashMap-的存储操作"><a href="#HashMap-的存储操作" class="headerlink" title="HashMap 的存储操作"></a>HashMap 的存储操作</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>下面我们详细讲一下 HashMap 是如何确定数组索引的位置、进行 put 操作的详细过程以及扩容机制 (resize)</p><h3 id="hash-计算，确定数组索引位置"><a href="#hash-计算，确定数组索引位置" class="headerlink" title="hash 计算，确定数组索引位置"></a>hash 计算，确定数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap 定位数组索引位置，直接决定了 hash 方法的离散性能。</p><p>看下源码的实现:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//jdk1.8</span>     <span class="token keyword">int</span> h<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// h = key.hashCode() 为第一步 取hashCode值</span>     <span class="token comment" spellcheck="true">// h ^ (h >>> 16) 为第二步 高位参与运算</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p><p>大家都知道上面代码里的 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。理论上散列值是一个 int 型，如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 进制 32 位带符号的 int 表值范围从‑2147483648 到 2147483648。前后加起来大概 40 亿的映射空间。</p><p>只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。你想，HashMap 扩容之前的数组初始大小才 16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个 indexFor( ) 函数里完成。</p><pre class=" language-java"><code class="language-java">bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//indexFor的代码也很简单，就是把散列值和数组长度做一个"与"操作，</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整次幂。因为这样（数组长度‑1）正好相当于一个 “低位掩码”。“与” 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16‑1=15。2 进制表示是 00000000 0000000000001111。和某散列值做 “与” 操作如下，结果就是截取了最低的四位值。</p><pre><code>10100101 11000100 00100101&amp; 00000000 00000000 00001111----------------------------------  00000000 00000000 00000101 //高位全部归零，只保留末四位</code></pre><p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。这时候 “扰动函数” 的价值就出来了，说到这大家应该都明白了，看下图。 </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201103230834282.png" alt="image-20201103230834282"></p><p>右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><h3 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal 方法"></a>putVal 方法</h3><p>HashMap 的 put 方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201103230804197.png" alt="image-20201103230804197"></p><p>源码以及解释如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 真正的put操作</span>    <span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果table没有初始化，或者初始化的大小为0，进行resize操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果hash值对应的桶内没有数据，直接生成结点并且把结点放入桶中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果hash值对应的桶内有数据解决冲突，再放入桶中</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断put的元素和已经存在的元素是相同(hash一致，并且equals返回true)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// put的元素和已经存在的元素是不相同(hash一致，并且equals返回true)</span>            <span class="token comment" spellcheck="true">// 如果桶内元素的类型是TreeNode，也就是解决hash解决冲突用的树型结构，把元素放入树种</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 桶内元素的类型不是TreeNode，而是链表时，把数据放入链表的最后一个元素上</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 如果链表的长度大于转换为树的阈值(TREEIFY_THRESHOLD)，将存储元素的数据结构变更为树</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 如果查已经存在key，停止遍历</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 已经存在元素时</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果K-V数量大于阈值，进行resize操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>扩容机制</strong></p><p>HashMap 的扩容机制用的很巧妙，以最小的性能来完成扩容。扩容后的容量就变成了变成了之前容量的 2 倍，初始容量为 16，所以经过 rehash 之后，元素的位置要么是在原位置，要么是在原位置再向高下标移动上次容量次数的位置，也就是说如果上次容量是 16，下次扩容后容量变成了 16+16，如果一个元素在下标为 7 的位置，下次扩容时，要不还在 7 的位置，要不在 7+16 的位置。</p><p>我们下面来解释一下 Java8 的扩容机制是怎么做到的？n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。 </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201103230904486.png" alt="image-20201103230904486"></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化： </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201103230922995.png" alt="image-20201103230922995"></p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成 “原索引 + oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图： </p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201103230937496.png" alt="image-20201103230937496"></p><p>而 hash 值的高位是否为 1，只需要和扩容后的长度做与操作就可以了，因为扩容后的长度为 2 的次幂，所以高位必为 1，低位必为 0，如 10000 这种形式，源码中有 <code>e.hash &amp; oldCap</code>[<code>注意这里是和oldCap而不是oladCap-1也不是newCap,得结果来判断增加得那个bit是0还是1</code>] 来做到这个逻辑。</p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。有一点注意区别，JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8 不会倒置。下面是 JDK1.8 的 resize 源码，写的很赞，如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算新的容量值和下一次要扩展的容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                     oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>                newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>            newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>            newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算新的resize上限</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>            newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>                      <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>        table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果位置上没有元素，直接为null</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果只有一个元素，新的hash计算后放入新的数组中</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                        newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果是树状结构，使用红黑树保存</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//如果是链表形式</span>                    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// preserve order</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                        <span class="token keyword">do</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//hash碰撞后高位为0，放入低Hash值的链表中</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//hash碰撞后高位为1，放入高Hash值的链表中</span>                            <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                    hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                                <span class="token keyword">else</span>                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                                hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 低hash值的链表放入数组的原始位置</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 高hash值的链表放入数组的原始位置 + 原始容量</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                            hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                            newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>作者：feigeswjtu</p><p>链接：<a href="https://github.com/feigeswjtu">https://github.com/feigeswjtu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代码中的注解多看几遍，其中HashMap的扩容机制是要必懂知识！结合图片一起理解！&lt;/p&gt;
&lt;h3 id=&quot;什么是-HashMap&quot;&gt;&lt;a href=&quot;#什么是-HashMap&quot; class=&quot;headerlink&quot; title=&quot;什么是 HashMap?&quot;&gt;&lt;/a&gt;什么是</summary>
      
    
    
    
    <category term="Java知识路线" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="Java" scheme="http://hans1980775481.github.io/tags/Java/"/>
    
    <category term="Java集合框架" scheme="http://hans1980775481.github.io/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    <category term="HashMap" scheme="http://hans1980775481.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0) 到底有什么用？</title>
    <link href="http://hans1980775481.github.io/2020/11/03/thread-sleep-0-dao-di-you-shi-me-yong/"/>
    <id>http://hans1980775481.github.io/2020/11/03/thread-sleep-0-dao-di-you-shi-me-yong/</id>
    <published>2020-11-03T14:56:22.000Z</published>
    <updated>2020-11-03T15:02:21.888Z</updated>
    
    <content type="html"><![CDATA[<p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？</p><p>思考下面这两个问题：</p><ul><li><p>假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2008-4-7 12:00:01.000 的时候，这个线程会不会被唤醒？</p></li><li><p>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？</p></li></ul><p>我们先回顾一下操作系统原理。</p><p>操作系统中，CPU竞争有很多种策略。<code>Unix系统使用的是时间片算法，而Windows则属于抢占式的</code>。</p><p>在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程 序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><p>所谓<code>抢占式操作系统</code>，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。</p><p>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一 个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。</p><p>我们用分蛋糕的场景来描述这两种算法。假设有源源不断的蛋糕（源源不断的时间），一副刀叉（一个CPU），10个等待吃蛋糕的人（10 个进程）。</p><p>如果是 <code>Unix操作系统</code>来负责分蛋糕，那么他会这样定规矩：每个人上来吃 1 分钟，时间到了换下一个。最后一个人吃完了就再从头开始。于是，不管这10个人是不是优先级不同、饥饿程度不同、饭量不同，每个人上来的时候都可以吃 1 分钟。当然，如果有人本来不太饿，或者饭量小，吃了30秒钟之后就吃饱了，那么他可以跟操作系统说：我已经吃饱了（挂起）。于是操作系统就会让下一个人接着来。</p><p>如果是 Windows 操作系统来负责分蛋糕的，那么场面就很有意思了。他会这样定规矩：我会根据你们的优先级、饥饿程度去给你们每个人计算一个优先级。优先级最高的那个人，可以上来吃蛋糕——吃到你不想吃为止。等这个人吃完了，我再重新根据优先级、饥饿程度来计算每个人的优先级，然后再分给优先级最高的那个人。</p><p>这样看来，这个场面就有意思了——可能有些人是PPMM，因此具有高优先级，于是她就可以经常来吃蛋糕。可能另外一个人是个丑男，而去很ws，所以优先级特别低，于是好半天了才轮到他一次（因为随着时间的推移，他会越来越饥饿，因此算出来的总优先级就会越来越高，因此总有一天会轮到他的）。而且，如果一不小心让一个大胖子得到了刀叉，因为他饭量大，可能他会霸占着蛋糕连续吃很久很久，导致旁边的人在那里咽口水。。。</p><p>而且，还可能会有这种情况出现：操作系统现在计算出来的结果，5号PPMM总优先级最高，而且高出别人一大截。因此就叫5号来吃蛋糕。5号吃了一小会儿，觉得没那么饿了，于是说“我不吃了”（挂起）。，关注公众号Java核心技术，回复关键字面试，获取最新的面试资料！因此操作系统就会重新计算所有人的优先级。</p><p>因为5号刚刚吃过，因此她的饥饿程度变小了，于是总优先级变小了；而其他人因为多等了一会儿，饥饿程度都变大了，所以总优先级也变大了。不过这时候仍然有可能5号的优先级比别的都高，只不过现在只比其他的高一点点——但她仍然是总优先级最高的啊。因此操作系统就会说：5号mm上来吃蛋糕……（5号mm心里郁闷，这不刚吃过嘛……人家要减肥……谁叫你长那么漂亮，获得了那么高的优先级）。</p><p>那么，Thread.Sleep 函数是干吗的呢？还用刚才的分蛋糕的场景来描述。上面的场景里面，5号MM在吃了一次蛋糕之后，觉得已经有8分饱了，她觉得在未来的半个小时之内都不想再来吃蛋糕了，那么她就会跟操作系统说：在未来的半个小时之内不要再叫我上来吃蛋糕了。</p><p>这样，操作系统在随后的半个小时里面重新计算所有人总优先级的时候，就会忽略5号mm。Sleep函数就是干这事的，他告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。</p><p>看完了 Thread.Sleep 的作用，我们再来想想文章开头的两个问题。</p><p>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。</p><p>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。</p><p>对于第二个问题，答案是：有，而且区别很明显。假设我们刚才的分蛋糕场景里面，有另外一个PPMM 7号，她的优先级也非常非常高（因为非常非常漂亮），所以操作系统总是会叫道她来吃蛋糕。而且，7号也非常喜欢吃蛋糕，而且饭量也很大。不过，7号人品很好，她很善良，她没吃几口就会想：如果现在有别人比我更需要吃蛋糕，那么我就让给他。</p><p>因此，她可以每吃几口就跟操作系统说：我们来重新计算一下所有人的总优先级吧。不过，操作系统不接受这个建议——因为操作系统不提供这个接口。于是7号mm就换了个说法：“在未来的0毫秒之内不要再叫我上来吃蛋糕了”。这个指令操作系统是接受的，于是此时操作系统就会重新计算大家的总优先级——注意这个时候是连7号一起计算的，因为“0毫秒已经过去了”嘛。因此如果没有比7号更需要吃蛋糕的人出现，那么下一次7号还是会被叫上来吃蛋糕。</p><p>因此，Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。</p><p>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。</p><p>实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p><blockquote><p>思考：sleep和wait得区别</p></blockquote><ul><li><a href="https://blog.csdn.net/u012050154/article/details/50903326">Java中sleep()与wait()区别</a></li></ul><p><strong><em>原文链接</em></strong></p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&mid=2247489697&idx=2&sn=29ab0ad7512f10ef90e434a5dd7b4d68&chksm=9f210d35a85684239eaa04eb3b25ca58c4a0e27b21ccb69c4ea64ad5eb3ff189b9217ed2feb9&mpshare=1&scene=24&srcid=1102MEdmVdxrVF8ki4lyYCY3&sharer_sharetime=1604315300208&sharer_shareid=0c62ce0359ab0b4c93ed31d8ff14913a&key=267493650bd514acd2f7cd1266b8f6be6f7458da136a06e3f94332558b44d0dfb533d7c161e818b505c987f2110be55b9dcc75f70c8957c54a7ed6fcab5f78c73255daf0fa12b92a5e7c08fdaf0eb0a8832c3d2dd5306b7e906baae8989332460dcfcb50249ba7cb01bac750f502624b17a7018a73e7dba701053cffa9cf90d8&ascene=14&uin=MjI5MDgzMTc4NA==&devicetype=Windows+10+x64&version=6209051a&lang=zh_CN&exportkey=AaaytsYfpDStEjkahCCk4Nk=&pass_ticket=PVsHFETN/hjxsDHQdaovKoNXrfZqVGrsNgnI7P5iBGX5v6aEO2l2Wr0rSiCOjz0L&wx_header=0">Thread.sleep(0) 到底有什么用？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？&lt;/p&gt;
&lt;p&gt;思考下面这两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设现在是 2008-4-7 12:00:00.000，如果我调用一下 Thread.Sl</summary>
      
    
    
    
    <category term="Java知识路线" scheme="http://hans1980775481.github.io/categories/Java%E7%9F%A5%E8%AF%86%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="Java" scheme="http://hans1980775481.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://hans1980775481.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git  常用命令</title>
    <link href="http://hans1980775481.github.io/2020/10/29/git-chang-yong-ming-ling/"/>
    <id>http://hans1980775481.github.io/2020/10/29/git-chang-yong-ming-ling/</id>
    <published>2020-10-29T02:25:15.000Z</published>
    <updated>2020-11-23T03:08:59.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天来给大家上一些干货</p></blockquote><h3 id="1-git-stash"><a href="#1-git-stash" class="headerlink" title="1. git stash"></a>1. git stash</h3><h3 id="2-git-rebase"><a href="#2-git-rebase" class="headerlink" title="2. git rebase"></a>2. git rebase</h3><h3 id="3-git-cherry-pick"><a href="#3-git-cherry-pick" class="headerlink" title="3. git cherry-pick"></a>3. git cherry-pick</h3><h3 id="4-git-push"><a href="#4-git-push" class="headerlink" title="4. git push"></a>4. git push</h3><blockquote><p>强制推送：<code>git push -f origin &lt;targetBranchName&gt;</code></p></blockquote><h3 id="5-git-reset"><a href="#5-git-reset" class="headerlink" title="5. git reset"></a>5. git reset</h3><p><strong><em>相关链接</em></strong></p><ul><li><a href="https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html">git cherry-pick 教程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NzczMTAzMg==&mid=2247491989&idx=1&sn=869dbbdf46b3c73e5cccff5334ea4e65&chksm=fd028122ca75083416e005960311197bc23e7cf7347b9b823968f22ed47c46adf74084a9b771&scene=126&sessionid=1603938100&key=6de4ce43f3b96379417b7566bd4b26c3e3022965d495b297bd0d65fcaac6ae1cdbf74927fca49e75faa24f3c0ff049de3114776bd6888b91c8bae9f2ee4d5b47b05d439499c14b55ec619359f1a73f654109202203b9ebd53e9b3412f39a377f3176acf3e0de0ebb2cd3f5ec9dabb06d00e1227907cd4a3a79491cdb0ca4a27e&ascene=1&uin=MjI5MDgzMTc4NA==&devicetype=Windows+10+x64&version=6209051a&lang=zh_CN&exportkey=AZXcWqvbevzdelmUZAkO578=&pass_ticket=/NxgvJX1fD9+ep792n4ruL8/V05an+tpUYTFvxeQRUAm6Ldc7dqIHPer2BY9CD8d&wx_header=0">Git Reset VS Git Revert</a></li><li><a href="https://www.yiibai.com/git/git_push.html">git push命令</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzA3MQ==&mid=2247488702&idx=1&sn=cc6b3e3e522958b33f068b73307b345b&chksm=fa80c6decdf74fc89df649f63b6eeb96ef6d3dd4a335473947270a7bc61fcc05c64cd156d2f3&mpshare=1&scene=1&srcid=1029h1hnBtBEQtQ9DuwLTXu4&sharer_sharetime=1603986574285&sharer_shareid=8889c91c58b491fac3b8bdc1cbb7953f&key=8c6fdd3cc892e824f95b5e226ba192904e4d7399f8f12ff415bed1718768a74e2b402d62f20115d219241b3e0453d31b49f349c0f31a916f1e9d5cb7ab0a94c856933acc861cf89bf8eb79bd589374f05336840ac125b567fd1a21801613f0fd9b43d42a599bb6f2cc06641bbcf99211e0e45523bbd01af93925a5c81b5e815e&ascene=1&uin=MjI5MDgzMTc4NA==&devicetype=Windows+10+x64&version=6209051a&lang=zh_CN&exportkey=ARvGza1THsuCppEZxNg3UJU=&pass_ticket=kEmdXH2+wHKahztBVv3jc34dG3fQCK9dNEKKjmBzhWJ/Yp7qtTAcovMPSljGs8Rg&wx_header=0">Git奇技|随意删除某个commit</a></li><li><a href="https://www.cnblogs.com/yxhblogs/p/10561879.html">巧用 git rebase 将某一部分 commit 复制到另一个分支</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天来给大家上一些干货&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-git-stash&quot;&gt;&lt;a href=&quot;#1-git-stash&quot; class=&quot;headerlink&quot; title=&quot;1. git stash&quot;&gt;&lt;/a&gt;1. git</summary>
      
    
    
    
    <category term="Git" scheme="http://hans1980775481.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://hans1980775481.github.io/tags/Git/"/>
    
    <category term="工作常用技能" scheme="http://hans1980775481.github.io/tags/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hexo--簡介</title>
    <link href="http://hans1980775481.github.io/2020/10/28/hexo-jian-jie/"/>
    <id>http://hans1980775481.github.io/2020/10/28/hexo-jian-jie/</id>
    <published>2020-10-28T14:58:30.000Z</published>
    <updated>2020-10-28T15:29:49.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Hexo生成界面原理"><a href="#1-Hexo生成界面原理" class="headerlink" title="1. Hexo生成界面原理"></a>1. Hexo生成界面原理</h3><blockquote><p>本節主要講述，Hexo怎麽生成界面的，我們寫的明明是Markdown文件爲什麽就可以變成HTML文件呢？以及MarkDown文件生成的HTML文件的對應關係是怎樣的呢？</p></blockquote><blockquote><p>首先我們來看一下，Hexo的文件目錄：</p><ul><li><code>node_modules:</code> 依赖包</li><li><code>public：</code>存放生成的页面</li><li><code>scaffolds：</code>生成文章的一些模板</li><li><code>source：</code>用来存放你的文章</li><li><code>themes：</code>主题**</li><li><code>_config.yml:</code> 博客的配置文件**</li></ul></blockquote><p>输入<code>hexo new post &quot;article title&quot;</code> 或者 <code>hexo n &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>你可以会直接在<code>vscode</code>里面编写<code>markdown</code>文件，可以实时预览，也可以用用其他编辑<code>md</code>文件的软件的工具编写。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，生成的靜態網頁均保存在<code>public</code>目錄下。</p><p>我們在<code>source</code>文件夾下的文件均會被編譯，到<code>public</code>文件夾下生成對應的<code>HTML</code>文件，<code>post</code>中的文件會在<code>public</code>文件夾中生成和文章時間一直的目錄最後會有如下目錄：</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201028231554092.png" alt="image-20201028231554092"></p><p>文章的内容會保存在<code>index.html</code>文件中</p><h4 id="1-2-layout（布局）"><a href="#1-2-layout（布局）" class="headerlink" title="1.2 layout（布局）"></a>1.2 layout（布局）</h4><hr><h5 id="1-2-1-post"><a href="#1-2-1-post" class="headerlink" title="1.2.1 post"></a><strong>1.2.1 post</strong></h5><p>当你每一次使用代码</p><pre class=" language-bash"><code class="language-bash">hexo new XXX</code></pre><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p><code>Hexo</code>有三种默认布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和<code>post</code>相同，都将储存到<code>source/_posts</code>文件夹。</p><p>而new这个命令其实是：</p><pre class=" language-bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span></code></pre><p>只不过这个<code>layout</code>默认是<code>post</code>罢了。</p><h5 id="1-2-4-2-page"><a href="#1-2-4-2-page" class="headerlink" title="1.2.4.2 page"></a><strong>1.2.4.2 page</strong></h5><p>如果你想另起一页，那么可以使用</p><pre class=" language-bash"><code class="language-bash">hexo new page newpage</code></pre><p>系统会自动给你在<code>source</code>文件夹下创建一个<code>newpage</code>文件夹，以及<code>newpage</code>文件夹中的<code>index.md</code>，这样你访问的<code>newpage</code>对应的链接就是<a href="http://xxx.xxx/newpage">http://xxx.xxx/newpage</a></p><blockquote><p>最終使用hexo g 生成界面時，就會生成<code>newpage/index.html</code>，如下：</p><p>hexo new page “about”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201028232032913.png" alt="image-20201028232032913"></p><h5 id="1-2-3-draft"><a href="#1-2-3-draft" class="headerlink" title="1.2.3 draft"></a><strong>1.2.3 draft</strong></h5><p><code>draft</code>是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><pre class=" language-bash"><code class="language-bash">hexo new draft newdraft</code></pre><p>这样会在<code>source/_draft</code>中新建一个<code>newdraft.md</code>文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><pre class=" language-bash"><code class="language-bash">hexo server --draft</code></pre><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到<code>post</code>中，</p><pre class=" language-bash"><code class="language-bash">hexo publish draft newdraft</code></pre><p>就会自动把<code>newdraft.md</code>发送到<code>post</code>中。</p><h4 id="1-3-Front-matter"><a href="#1-3-Front-matter" class="headerlink" title="1.3 Front-matter"></a>1.3 Front-matter</h4><blockquote><p><code>scaffolds：</code>生成文章的一些模板</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201028232230247.png" alt="image-20201028232230247"></p><blockquote><ul><li><code>draft.md</code>: 生成草稿文件的模板</li><li><code>page.md</code>: 生成頁面文件的模板</li><li><code>post.md</code>: 生成文章文件的模板</li></ul></blockquote><hr><p><code>Front-matter</code> 是<code>md</code>文件最上方以 <code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：</p><pre><code>title: Hexo+Github博客搭建记录date: 2019-08-10 21:44:44</code></pre><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><p>参数描述<code>layout</code>布局<code>title</code>标题<code>date</code>建立日期<code>updated</code>更新日期<code>comments</code>开启文章的评论功能<code>tags</code>标签（不适用于分页）<code>categories</code>分类（不适用于分页）<code>permalink</code>覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说<code>Foo</code>，<code>Bar</code>不等于<code>Bar</code>，<code>Foo</code>；而标签没有顺序和层次。</p><pre class=" language-yml"><code class="language-yml">---title: Hexo+Github博客搭建记录date: 2019-08-10 21:44:44author: 洪卫img: /medias/banner/7.jpgcoverImg: /medias/banner/7.jpgtop: truecover: truetoc: truepassword: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置---</code></pre><p><strong><em>相關鏈接</em></strong></p><ul><li><a href="https://www.cnblogs.com/shwee/p/11421156.html">Hexo+Github: 个人博客网站搭建完全教程(看这篇就够了)</a></li><li><a href="http://oyjt.github.io/2016/01/14/%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/">使用hexo创建github博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/44213627">hexo超完整的搭建教程，让你拥有一个专属个人博客</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Hexo生成界面原理&quot;&gt;&lt;a href=&quot;#1-Hexo生成界面原理&quot; class=&quot;headerlink&quot; title=&quot;1. Hexo生成界面原理&quot;&gt;&lt;/a&gt;1. Hexo生成界面原理&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本節主要講述，Hexo怎麽生成</summary>
      
    
    
    
    <category term="hexo博客搭建" scheme="http://hans1980775481.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="http://hans1980775481.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-评论系统插件</title>
    <link href="http://hans1980775481.github.io/2020/10/25/hexo-ping-lun-xi-tong-cha-jian/"/>
    <id>http://hans1980775481.github.io/2020/10/25/hexo-ping-lun-xi-tong-cha-jian/</id>
    <published>2020-10-25T15:40:27.000Z</published>
    <updated>2020-10-25T16:25:25.381Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>本文，我们主要来讨论一下，如何使用Hexo系统在<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>主题下，完成评论功能使用。</p><p><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>支持多种评论插件的搭配使用：<a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p><p>本篇博客中主要讨论使用Valine的评论系统来完成，评论功能的使用。</p></blockquote><h3 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1. 注册账号"></a>1. 注册账号</h3><p><a href="https://www.leancloud.cn/">leancloud官网</a>需要现先在官网注册一个账户</p><h3 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2. 创建应用"></a>2. 创建应用</h3><blockquote><p>注册完账号之后，创建一个用于评论数据的应用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201025235952054.png" alt="image-20201025235952054"></p><blockquote><p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026000038758.png" alt="image-20201026000038758"></p><h3 id="3-安全域名"><a href="#3-安全域名" class="headerlink" title="3. 安全域名"></a>3. 安全域名</h3><p>为了你的数据安全，请设置自己的<code>安全域名</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026000559211.png" alt="image-20201026000559211"></p><h3 id="4-域名配置"><a href="#4-域名配置" class="headerlink" title="4. 域名配置"></a>4. 域名配置</h3><blockquote><p>由于我们创建的这个应用，使用的是Leancloud配置的默认域名，只有3个月的使用期限，我们可以看到如下提示：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026001514066.png" alt="image-20201026001514066"></p><blockquote><p>所以我们尽量，为这个应用配置一个我们自己的域名</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026001620151.png" alt="image-20201026001620151"></p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026001957169.png" alt="image-20201026001957169"></p><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026002111146.png" alt="image-20201026002111146"></p><h3 id="5-hexo配置使用"><a href="#5-hexo配置使用" class="headerlink" title="5. hexo配置使用"></a>5. hexo配置使用</h3><blockquote><p>完成数据应用的配置之后，就可以在<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>的主题配置文件下，编辑<code>_config.yml</code>文件中的Valine配置</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026000946659.png" alt="image-20201026000946659"></p><blockquote><p><code>appId</code>和<code>appKey</code>要和数据应用中的一致，然后，在Hexo博客的更目录下执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>，访问<code>http://localhost:4000</code>然后选择一篇文章，即可看到文章底部有评论界面。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201026001303572.png" alt="image-20201026001303572"></p><blockquote><p>hint: 如果Leancloud的应用太久没用的话，会被archive，我们登陆LeanCloud重新激活应用即可。</p></blockquote><p><strong><em>相关链接</em></strong></p><ul><li><a href="https://valine.js.org/quickstart.html">Valine 介绍</a></li><li><a href="https://juejin.im/entry/6844903683356885000">hexo博客评论新神器——Valine</a></li><li><a href="https://dev66.xyz/2020/01/valine-error.html">Valine的错误信息</a></li><li><a href="https://cjjkkk.github.io/gitalk/">使用gittalk实现hexo博客评论功能| Jacky Cheng</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文，我们主要来讨论一下，如何使用Hexo系统在&lt;a href=&quot;https://github.com/blinkfox/hexo-theme-matery&quot;&gt;hexo-theme-matery&lt;/a&gt;主题下，完成评论功能使用。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="hexo博客搭建" scheme="http://hans1980775481.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="http://hans1980775481.github.io/tags/hexo/"/>
    
    <category term="评论系统" scheme="http://hans1980775481.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://hans1980775481.github.io/2020/10/17/hello-world/"/>
    <id>http://hans1980775481.github.io/2020/10/17/hello-world/</id>
    <published>2020-10-17T02:38:12.484Z</published>
    <updated>2020-10-17T02:38:12.484Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://hans1980775481.github.io/2020/10/17/test/"/>
    <id>http://hans1980775481.github.io/2020/10/17/test/</id>
    <published>2020-10-16T18:24:52.000Z</published>
    <updated>2020-10-26T08:41:08.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你看到我了吗</p></blockquote><p>github page访问不了的常见问题：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/165496817">如何正确的给hexo、hugo等静态博客做好dns解析？</a></p></li><li><p><a href="https://zpjiang.me/2020/01/15/let-baidu-index-github-page/">解决百度爬虫无法爬取 Github Pages 个人博客的问题</a></p></li><li><p><a href="https://github.com/Tencent/kbone/issues/288">我这里打不开文档地址了</a></p></li><li><p><a href="https://v2ex.com/t/694988">一脸懵逼， github 域名竟然被解析到 127.0.0.1 了</a></p></li><li><p><a href="https://blog.csdn.net/qq_36759224/article/details/100879609">Hexo 双线部署到 Coding Pages 和 GitHub Pages 并实现全站 HTTPS</a></p></li></ul><p>alter  table table1 modify column1  decimal(10,2)</p><p>ALTER TABLE thermometer modify cpuusage double;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你看到我了吗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;github page访问不了的常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/165496817&quot;&gt;如何正确的给hex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo  搭建教程</title>
    <link href="http://hans1980775481.github.io/2020/10/16/hexo-da-jian-jiao-cheng/"/>
    <id>http://hans1980775481.github.io/2020/10/16/hexo-da-jian-jiao-cheng/</id>
    <published>2020-10-16T03:22:23.000Z</published>
    <updated>2020-10-25T15:08:12.875Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p> 让我们看看能不能展示图片</p></blockquote><ul><li>同名文件夹中的图片引用可以直接使用图片名即可引用图片</li></ul><p><img src="image-20201016112531594.png" alt="image-20201016112531594"></p><ul><li>使用远程文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/hans1980775481/picture-bed/img/image-20201016112531594.png" alt="image-20201016112531594"></p><ul><li>使用相对路径是引用不到图片的</li></ul><p><img src="_image/hexo-%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/image-20201016125419332.png" alt="image-20201016125419332"></p><p><strong><em>相关链接</em></strong></p><ul><li><a href="https://leay.net/2019/12/25/hexo/">Hexo 引用本地图片以及引用本地任意位置图片的一点思路</a></li><li><a href="https://www.jianshu.com/p/cd623d82c00a">Hexo博客新建文章并发布</a></li></ul><h4 id="使用Hexo-如何初始化"><a href="#使用Hexo-如何初始化" class="headerlink" title="使用Hexo 如何初始化"></a>使用Hexo 如何初始化</h4><ol><li>初始化内容<ul><li>分类</li><li>标签</li><li>关于我</li><li>等等</li></ul></li><li>如何在文章中配置分类、标签等信息</li></ol><p><strong><em>相关链接</em></strong></p><ul><li><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E9%85%8D%E7%BD%AE">配置</a></li><li><a href="https://ijiaober.github.io/2014/08/05/hexo/hexo-04/">Hexo使用攻略：（四）Hexo的分类和标签设置</a></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></li><li><a href="https://blog.csdn.net/qq_32337109/article/details/78755662">hexo 创建文章、标签、分类</a></li><li><a href="https://blog.csdn.net/qq_38747027/article/details/107967518">hexo博客front-matter格式</a></li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> CentOS7下Tomcat启动慢的原因及解决方案<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2017-12-02 21:01:24</span><span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#是否可评论</span><span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#是否显示文章目录</span><span class="token key atrule">categories</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#分类</span>    <span class="token punctuation">-</span> 云服务器<span class="token key atrule">tags</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#标签</span>    <span class="token punctuation">-</span> centOS    <span class="token punctuation">-</span> tomcat<span class="token punctuation">---</span><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 标题<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2020-02-29 16:00:00</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 文章摘要</span><span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">abbrlink</span><span class="token punctuation">:</span> <span class="token number">213245 </span><span class="token comment" spellcheck="true"># 自己可随意设置</span><span class="token key atrule">img</span><span class="token punctuation">:</span> <span class="token string">'https://img-blog.csdnimg.cn/20200309120551356.png'</span> <span class="token comment" spellcheck="true"># 设置文章背景图，设置为外链图片，访问快</span><span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 算法  <span class="token punctuation">-</span> 计算机知识<span class="token key atrule">categories</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 算法<span class="token key atrule">author</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 设置文章作者</span><span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 设置密码（yml中开启相应功能）</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 轮播图片</span><span class="token punctuation">---</span><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><blockquote><p>npm的一些使用操作：</p></blockquote><h2 id="npm-插件安装"><a href="#npm-插件安装" class="headerlink" title="npm 插件安装"></a>npm 插件安装</h2><h3 id="查看插件"><a href="#查看插件" class="headerlink" title="查看插件"></a>查看插件</h3><pre class=" language-shell"><code class="language-shell">npm list</code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><pre class=" language-shell"><code class="language-shell">npm install dplayer --savenpm install hexo-tag-dplayer</code></pre><p>如何使用：</p><pre class=" language-shell"><code class="language-shell">&#123;% dplayer "url=http://home.ustc.edu.cn/~mmmwhy/GEM.mp4"  "pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %&#125;</code></pre><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><pre class=" language-shell"><code class="language-shell">npm install aplayer --savenpm install hexo-tag-aplayer</code></pre><p>如何使用：</p><pre class=" language-shell"><code class="language-shell">&#123;% aplayer "HUSH" "Lasse Lindh" "http://opj0cbfmf.bkt.clouddn.com/Part.3%20Lasse%20Lindh%20-%20Hush.mp3"  "http://opj0cbfmf.bkt.clouddn.com/hush.jpg" "autoplay=false" %&#125;</code></pre><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><pre class=" language-shell"><code class="language-shell">npm install hexo-deployer-git --save</code></pre><h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><pre class=" language-shell"><code class="language-shell">npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save</code></pre><h3 id="gulp压缩"><a href="#gulp压缩" class="headerlink" title="gulp压缩"></a>gulp压缩</h3><pre class=" language-shell"><code class="language-shell">npm install --global gulp-clinpm install --save-dev gulpnpm i gulp gulp-clean-css gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-uglify -Snpm install --save-dev gulp delnpm install --save-dev run-sequencenpm install gulp-minify-css --save-dev</code></pre><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><pre class=" language-shell"><code class="language-shell">npm install hexo-generator-search --save</code></pre><h3 id="百度主动提交"><a href="#百度主动提交" class="headerlink" title="百度主动提交"></a>百度主动提交</h3><pre class=" language-shell"><code class="language-shell">npm install hexo-baidu-url-submit --save</code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre class=" language-shell"><code class="language-shell">npm uninstall <你的插件名></code></pre><p><strong><em>相关链接</em></strong></p><ul><li><a href="https://www.dazhuanlan.com/2019/10/12/5da110cdd9a7b/">卸载 hexo 插件</a></li></ul><h4 id="好看的主题以及相关地址："><a href="#好看的主题以及相关地址：" class="headerlink" title="好看的主题以及相关地址："></a>好看的主题以及相关地址：</h4><ul><li><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery主题</a></li><li><a href="https://github.com/godweiyang/hexo-matery-modified">hexo-matery-modified</a></li><li><a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">hexo-theme-yilia-plus</a></li></ul><h4 id="一些好的文章："><a href="#一些好的文章：" class="headerlink" title="一些好的文章："></a>一些好的文章：</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程</a></li><li><a href="https://hexo.io/zh-cn/docs/configuration">hexo中文官网</a></li><li><a href="https://www.jianshu.com/p/efaf72aab32e">Hexo 博客从搭建部署到SEO优化等详细教程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt; 让我们看看能不能展示图片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;同名文件夹中的图片引用可以直接使用图片名即可引用图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;image-20201016112531594.png</summary>
      
    
    
    
    <category term="hexo博客搭建" scheme="http://hans1980775481.github.io/categories/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="hexo" scheme="http://hans1980775481.github.io/tags/hexo/"/>
    
    <category term="博客" scheme="http://hans1980775481.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
